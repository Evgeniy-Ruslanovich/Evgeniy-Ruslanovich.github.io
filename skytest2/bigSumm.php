<?php
/*
Максимальное целое в 32-битных системах - 2147483647, и имеет 10 разрядов.
Любое 9-разрядное число не будет превышать этот порог, и их сумма тоже. То есть мы можем спокойно складывать два 9-разрядных числа.
для 64-разрядных - безопасное число разрядов - 18. Мы можем узнать текущее максимальное число с помощью константы PHP_INT_MAX

Алгоримт функции подобен вычислению "столбиком". Только мы складываем не по одному разряду, а сразу по 9 или 18. Если получилась лишняя цифра, переносим ее на более старший разряд.
Промежуточные суммы конкатенируем. Таким обзаром размер складываемых чисел ограничен только максимальным размером строки или общим лимитом памяти
*/

$max_digit = strlen(PHP_INT_MAX) - 1;
define('MAX_DIGIT',$max_digit);

function bigSumm($a,$b){
	$sum = '';
	$bigger_len = (strlen($a) > strlen($b) ? strlen($a) : strlen($b));
	$cycles = ceil($bigger_len / MAX_DIGIT);

	$to_next_digit = 0;
	for($i=0;$i<$cycles;$i++){
		if(strlen($a) > MAX_DIGIT){
			$a_part = substr($a, -MAX_DIGIT);
			$a = substr($a, 0, - MAX_DIGIT);
		} else {
			$a_part = $a;
			$a = '';
		}
		if(strlen($b) > MAX_DIGIT){
			$b_part = substr($b, - MAX_DIGIT);
			$b = substr($b, 0, - MAX_DIGIT);
		} else {
			$b_part = $b;
			$b = '';
		}
		/*Примечание: Можно было обойтись и без этого условия strlen($a) > MAX_DIGIT, 
		Оставить только строки 
			$a_part = substr($a, - MAX_DIGIT);
			$a = substr($a, 0, - MAX_DIGIT);
		В таком случае, если $a меньше MAX_DIGIT, то $a_part принимало бы значение $a, а само $a принимало бы значение false, и на следующей итерации при попытке опять обратиться через substr превращалось бы в пустую строку.
		Но это поведение не является таким уж очевидным, и я предпочитаю явно контролировать процесс, где это возможно, а не полагаться на неявное поведение функций и приведение типов.
		Если явно прописать условия, это делает код более очевидным, что соответствует принципу KISS
		Также в коде присутствуют повторы, однотипные действия для $a и $b, что противоречит DRY. Можно было бы вынести в отдельную функцию, но, на мой взгляд, в данном случае это было бы нецелесообразно, код стал бы менее понятным и более сложным. С другой стороны, если бы у нас было больше двух слагаемых, или неопределенное количество слагаемых (допустим, мы принимаем массив в виде аргумента) то такая функция могла бы пригодиться. Но думать о многих слагаемых, когда у нас задача касается только двух, протеворечит YAGNI*/

		$tmp_sum = (int)$a_part + (int)$b_part + $to_next_digit;
		$tmp_sum_str = (string)$tmp_sum;
		if(strlen($tmp_sum_str) > MAX_DIGIT){
			$to_next_digit = (int)substr($tmp_sum_str, 0, - MAX_DIGIT);
			$tmp_sum_str = substr($tmp_sum_str,- MAX_DIGIT);
		} else {
			$to_next_digit = 0;
		}
		$sum = $tmp_sum_str . $sum;
		echo "Цикл " . $i . "|a_part:" . $a_part . " |b_part:" . $b_part . " |a:" . $a . " |b:" . $b . "<br>";
		echo "Временая сумма: " . $tmp_sum_str . "|На следующий разряд: " . $to_next_digit . "|Текущая общая сумма: " . $sum . "<br><br>";
	}
	if($to_next_digit > 0){
		$sum = $to_next_digit . $sum; //на случай, еслив последней итерации были 9-значные числа, и сумма вышла за пределы разряда
	}
	return $sum;
}
